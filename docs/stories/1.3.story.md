# Story 1.3: Create UIManager Singleton

**Epic:** Epic 1 - Foundation & Setup
**Story ID:** 1.3
**Priority:** High
**Points:** 3
**Status:** Draft

---

## Description

Implement a centralized UIManager singleton to manage screen navigation, transitions, and UI state throughout the game. The manager provides a clean API for switching between screens, handling back button navigation with a screen stack, and orchestrating UI transitions with DOTween animations. This foundational system enables seamless navigation in Epic 5 (UI/UX Implementation).

**GDD Reference:** Architecture > Core Manager Singletons (Epic 1 Deliverable)

This story establishes the UI navigation infrastructure required before implementing screen-specific UI in Epic 5 (Main Menu, Game Screen, Lesson List, Profile, Leaderboard, Settings).

---

## Acceptance Criteria

### Functional Requirements

- [ ] **AC1:** UIManager exists as singleton MonoBehaviour, persists across scenes (DontDestroyOnLoad)
- [ ] **AC2:** Screen registration system: `RegisterScreen(Screen screenType, GameObject screenObject)`
- [ ] **AC3:** Screen switching method: `ShowScreen(Screen screenType, bool animate = true, float duration = 0.3f)`
- [ ] **AC4:** Back button navigation: `GoBack()` pops screen stack and returns to previous screen
- [ ] **AC5:** Screen stack system tracks navigation history (max depth: 10)
- [ ] **AC6:** Screen lifecycle events: `OnScreenEnter(Screen screen)`, `OnScreenExit(Screen screen)`
- [ ] **AC7:** Optional fade transition animation using DOTween (fade out → switch → fade in)
- [ ] **AC8:** UIManager initializes on Boot scene load, ready for use in MainMenu scene

### Technical Requirements

- [ ] **TR1:** Uses Canvas with CanvasGroup for fade animations
- [ ] **TR2:** Follows singleton pattern from architecture coding standards
- [ ] **TR3:** Thread-safe screen switching (prevents double-tap issues)
- [ ] **TR4:** Screen objects managed via Dictionary<Screen, GameObject>
- [ ] **TR5:** Screen enum extensible for future screens (Epic 5+)

### Game Design Requirements

- [ ] **GD1:** Default screen transition duration: 0.3 seconds (quick but smooth)
- [ ] **GD2:** Fade animation uses Ease.InOutQuad for professional feel
- [ ] **GD3:** Back button always returns to previous screen (navigation stack)

---

## Technical Specifications

### Files to Create/Modify

**New Files:**

- `Assets/_Project/Scripts/Managers/UIManager.cs` - UI manager singleton
- `Assets/_Project/Scripts/UI/Screen.cs` - Screen enum definition

**Modified Files:**

- `Assets/_Project/Scenes/Boot.unity` - Add UIManager GameObject
- (Future) Screen scripts in Epic 5 will register themselves with UIManager on Awake

### Class Definition

```csharp
// Screen.cs
namespace SocialOwareAcademy.UI
{
    /// <summary>
    /// Enum representing all screens in the game.
    /// </summary>
    public enum Screen
    {
        None = 0,
        MainMenu = 1,
        Game = 2,
        LessonList = 3,
        LessonIntro = 4,
        LessonPuzzle = 5,
        LessonSummary = 6,
        Profile = 7,
        Leaderboard = 8,
        Settings = 9,
        Onboarding = 10,
        PlayModeSelection = 11,
        MatchResult = 12
    }
}
```

```csharp
// UIManager.cs
using UnityEngine;
using System.Collections.Generic;
using DG.Tweening;
using SocialOwareAcademy.UI;

namespace SocialOwareAcademy.Managers
{
    /// <summary>
    /// Centralized UI management for screen navigation and transitions.
    /// Singleton pattern, persists across scenes.
    /// </summary>
    public class UIManager : MonoBehaviour
    {
        public static UIManager Instance { get; private set; }

        [Header("Transition Settings")]
        [SerializeField] private float defaultTransitionDuration = 0.3f;
        [SerializeField] private Ease transitionEase = Ease.InOutQuad;
        [SerializeField] private int maxScreenStackDepth = 10;

        [Header("Canvas Setup")]
        [SerializeField] private Canvas mainCanvas;
        [SerializeField] private CanvasGroup canvasGroup;

        // Screen management
        private Dictionary<Screen, GameObject> screens = new Dictionary<Screen, GameObject>();
        private Stack<Screen> screenStack = new Stack<Screen>();
        private Screen currentScreen = Screen.None;
        private bool isTransitioning = false;

        // Events
        public System.Action<Screen> OnScreenEnter;
        public System.Action<Screen> OnScreenExit;

        void Awake()
        {
            // Singleton pattern
            if (Instance != null && Instance != this)
            {
                Destroy(gameObject);
                return;
            }

            Instance = this;
            DontDestroyOnLoad(gameObject);

            // Initialize canvas
            InitializeCanvas();

            Debug.Log("[UIManager] Initialized");
        }

        private void InitializeCanvas()
        {
            // Create main canvas if not assigned
            if (mainCanvas == null)
            {
                GameObject canvasObj = new GameObject("MainCanvas");
                canvasObj.transform.SetParent(transform);
                mainCanvas = canvasObj.AddComponent<Canvas>();
                mainCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
                mainCanvas.sortingOrder = 0;

                // Add CanvasScaler for responsive design
                var scaler = canvasObj.AddComponent<UnityEngine.UI.CanvasScaler>();
                scaler.uiScaleMode = UnityEngine.UI.CanvasScaler.ScaleMode.ScaleWithScreenSize;
                scaler.referenceResolution = new Vector2(1080, 1920); // Portrait orientation
                scaler.matchWidthOrHeight = 0.5f;

                // Add GraphicRaycaster for UI interaction
                canvasObj.AddComponent<UnityEngine.UI.GraphicRaycaster>();
            }

            // Create CanvasGroup for fade transitions
            if (canvasGroup == null)
            {
                canvasGroup = mainCanvas.gameObject.AddComponent<CanvasGroup>();
                canvasGroup.alpha = 1f;
                canvasGroup.interactable = true;
                canvasGroup.blocksRaycasts = true;
            }
        }

        /// <summary>
        /// Register a screen for management by UIManager.
        /// Called by screen scripts on Awake.
        /// </summary>
        public void RegisterScreen(Screen screenType, GameObject screenObject)
        {
            if (screens.ContainsKey(screenType))
            {
                Debug.LogWarning($"[UIManager] Screen {screenType} already registered. Overwriting.");
            }

            screens[screenType] = screenObject;
            screenObject.SetActive(false); // Hide by default
            screenObject.transform.SetParent(mainCanvas.transform, false);

            Debug.Log($"[UIManager] Registered screen: {screenType}");
        }

        /// <summary>
        /// Unregister a screen (called on screen Destroy).
        /// </summary>
        public void UnregisterScreen(Screen screenType)
        {
            if (screens.ContainsKey(screenType))
            {
                screens.Remove(screenType);
                Debug.Log($"[UIManager] Unregistered screen: {screenType}");
            }
        }

        /// <summary>
        /// Show a specific screen with optional animation.
        /// Adds to screen stack for back button navigation.
        /// </summary>
        public void ShowScreen(Screen screenType, bool animate = true, float duration = -1f)
        {
            if (isTransitioning)
            {
                Debug.LogWarning("[UIManager] Screen transition already in progress. Ignoring.");
                return;
            }

            if (!screens.ContainsKey(screenType))
            {
                Debug.LogError($"[UIManager] Screen {screenType} not registered. Cannot show.");
                return;
            }

            if (duration < 0)
                duration = defaultTransitionDuration;

            if (animate)
            {
                StartCoroutine(AnimatedTransition(screenType, duration));
            }
            else
            {
                ExecuteScreenSwitch(screenType);
            }
        }

        /// <summary>
        /// Navigate back to previous screen in stack.
        /// </summary>
        public void GoBack()
        {
            if (screenStack.Count <= 1)
            {
                Debug.LogWarning("[UIManager] No previous screen in stack. Cannot go back.");
                return;
            }

            // Remove current screen from stack
            screenStack.Pop();

            // Get previous screen
            Screen previousScreen = screenStack.Peek();
            ShowScreen(previousScreen, animate: true);
        }

        /// <summary>
        /// Clear screen stack and show specified screen.
        /// Used for major navigation changes (e.g., logout, main menu).
        /// </summary>
        public void ShowScreenAndClearStack(Screen screenType, bool animate = true)
        {
            screenStack.Clear();
            ShowScreen(screenType, animate);
        }

        private System.Collections.IEnumerator AnimatedTransition(Screen targetScreen, float duration)
        {
            isTransitioning = true;
            canvasGroup.interactable = false;

            // Fade out
            yield return canvasGroup.DOFade(0f, duration * 0.5f)
                .SetEase(transitionEase)
                .WaitForCompletion();

            // Switch screen
            ExecuteScreenSwitch(targetScreen);

            // Fade in
            yield return canvasGroup.DOFade(1f, duration * 0.5f)
                .SetEase(transitionEase)
                .WaitForCompletion();

            canvasGroup.interactable = true;
            isTransitioning = false;
        }

        private void ExecuteScreenSwitch(Screen targetScreen)
        {
            // Exit current screen
            if (currentScreen != Screen.None && screens.ContainsKey(currentScreen))
            {
                screens[currentScreen].SetActive(false);
                OnScreenExit?.Invoke(currentScreen);
                Debug.Log($"[UIManager] Exited screen: {currentScreen}");
            }

            // Enter new screen
            currentScreen = targetScreen;
            screens[targetScreen].SetActive(true);
            OnScreenEnter?.Invoke(targetScreen);
            Debug.Log($"[UIManager] Entered screen: {targetScreen}");

            // Add to screen stack (avoid duplicates of same screen)
            if (screenStack.Count == 0 || screenStack.Peek() != targetScreen)
            {
                screenStack.Push(targetScreen);

                // Limit stack depth
                if (screenStack.Count > maxScreenStackDepth)
                {
                    Debug.LogWarning($"[UIManager] Screen stack exceeded max depth ({maxScreenStackDepth}). Clearing oldest entries.");
                    var stackList = new List<Screen>(screenStack);
                    stackList.RemoveAt(stackList.Count - 1); // Remove oldest
                    screenStack = new Stack<Screen>(stackList);
                }
            }
        }

        // Public getters for UI
        public Screen CurrentScreen => currentScreen;
        public bool IsTransitioning => isTransitioning;
        public int ScreenStackDepth => screenStack.Count;

        /// <summary>
        /// Check if a screen is registered.
        /// </summary>
        public bool IsScreenRegistered(Screen screenType)
        {
            return screens.ContainsKey(screenType);
        }
    }
}
```

### Integration Points

**Boot Scene Setup:**

1. Create empty GameObject named "UIManager" in Boot scene
2. Attach `UIManager.cs` script
3. Leave all fields default (Canvas will be created at runtime)

**Usage Example (Future Stories):**

```csharp
// From any script, show a screen
UIManager.Instance.ShowScreen(Screen.MainMenu, animate: true);

// Navigate back
UIManager.Instance.GoBack();

// Listen to screen events
UIManager.Instance.OnScreenEnter += (screen) => {
    Debug.Log($"Entered screen: {screen}");
};

// Future screen script (Epic 5) registers itself:
public class MainMenuScreen : MonoBehaviour
{
    void Awake()
    {
        UIManager.Instance.RegisterScreen(Screen.MainMenu, gameObject);
    }

    void OnDestroy()
    {
        if (UIManager.Instance != null)
        {
            UIManager.Instance.UnregisterScreen(Screen.MainMenu);
        }
    }
}
```

---

## Dev Notes

### Architecture References

**Manager Singleton Pattern:** [Source: architecture.md#8.2-unity-best-practices > Singleton Pattern]
- Follow standard singleton implementation with DontDestroyOnLoad
- Single instance across all scenes

**UI System:** Architecture mentions UIManager as required manager (Epic 1 deliverables)
- No detailed UI architecture document exists yet (will be expanded in Epic 5)
- This story creates minimal viable UI navigation system for MVP

**Performance Requirements:** [Source: architecture.md#9-performance-requirements]
- Screen transitions must not impact 60 FPS target
- Use DOTween for smooth fade animations (already optimized)

### Design Decisions

**Why Screen Stack:**
- Enables intuitive back button navigation (Android back button, in-game back buttons)
- Stack depth limit (10) prevents memory issues from deep navigation chains
- Epic 5 will implement back button listeners (Android hardware back button)

**Why CanvasGroup Fade:**
- Simple, performant fade transition suitable for MVP
- DOTween interpolation ensures smooth 60 FPS animation
- Future: Can add slide transitions, scale effects (Epic 7 polish)

**Screen Enum Design:**
- Centralized enum prevents typos, enables compile-time safety
- Extensible for future screens (V1.1+: Friends screen, Shop screen)
- None = 0 reserved for "no screen active" state

**Why Dictionary for Screen Management:**
- O(1) lookup performance for screen switching
- Prevents duplicate screen registrations
- Future: Can add screen prefab instantiation if needed (Epic 5)

---

## Implementation Tasks

### Dev Agent Record

**Tasks:**

- [ ] **Task 1:** Create `Managers` folder (if not exists): `Assets/_Project/Scripts/Managers/`
- [ ] **Task 2:** Create `UI` folder (if not exists): `Assets/_Project/Scripts/UI/`
- [ ] **Task 3:** Implement `Screen.cs` enum
- [ ] **Task 4:** Implement `UIManager.cs` with all required methods
- [ ] **Task 5:** Add UIManager GameObject to Boot scene
- [ ] **Task 6:** Test singleton pattern (verify DontDestroyOnLoad works across scene loads)
- [ ] **Task 7:** Create test screen GameObjects (empty panels) for MainMenu, Game, Settings
- [ ] **Task 8:** Test RegisterScreen with test screens
- [ ] **Task 9:** Test ShowScreen with animation enabled (verify fade transition smooth at 60 FPS)
- [ ] **Task 10:** Test ShowScreen without animation (instant switch)
- [ ] **Task 11:** Test screen stack navigation (show 3 screens, call GoBack twice, verify correct navigation)
- [ ] **Task 12:** Test ShowScreenAndClearStack (verify stack cleared)
- [ ] **Task 13:** Test double-tap prevention (rapid ShowScreen calls should be ignored)
- [ ] **Task 14:** Test OnScreenEnter and OnScreenExit events fire correctly
- [ ] **Task 15:** Profile performance (verify no frame drops during transitions)
- [ ] **Task 16:** Delete test screen GameObjects after verification

**Debug Log:**
| Task | File | Change | Reverted? |
|------|------|--------|-----------|
|  |  |  |  |

**Completion Notes:**

<!-- Only note deviations from requirements, keep under 50 words -->

**Change Log:**

<!-- Only requirement changes during implementation -->

---

## Game Design Context

**GDD Reference:** Architecture > Core Manager Singletons

**Game Mechanic:** UI Navigation System Foundation

**Player Experience Goal:**
- Seamless navigation between screens enhances polish
- Smooth transitions create premium feel
- Back button navigation matches platform conventions (Android)

**Balance Parameters:**

- **Default Transition Duration:** 0.3 seconds - quick enough to feel responsive, slow enough to be smooth
- **Transition Easing:** Ease.InOutQuad - professional animation curve
- **Max Screen Stack Depth:** 10 - prevents edge case memory issues, sufficient for typical navigation

---

## Testing Requirements

### Manual Testing

**Test Cases:**

1. **TC1: Singleton Pattern**
   - Start Boot scene
   - Load MainMenu scene
   - Expected: UIManager persists, single instance exists
   - Check: Only one UIManager in Hierarchy after scene load

2. **TC2: Screen Registration**
   - Create test GameObject (empty panel)
   - Call `RegisterScreen(Screen.MainMenu, testObject)`
   - Expected: Screen registered, object parented to MainCanvas, object inactive
   - Call `ShowScreen(Screen.MainMenu)`
   - Expected: Screen activates

3. **TC3: Animated Screen Transition**
   - Register 2 test screens
   - Call `ShowScreen(Screen.MainMenu, animate: true)`
   - Call `ShowScreen(Screen.Game, animate: true)`
   - Expected: Fade out → switch → fade in, smooth 60 FPS, 0.3s duration
   - Performance: No frame drops

4. **TC4: Instant Screen Transition**
   - Register 2 test screens
   - Call `ShowScreen(Screen.MainMenu, animate: false)`
   - Expected: Instant switch, no animation

5. **TC5: Back Navigation**
   - Show MainMenu → Game → Settings
   - Call `GoBack()`
   - Expected: Returns to Game screen
   - Call `GoBack()` again
   - Expected: Returns to MainMenu screen

6. **TC6: Clear Stack Navigation**
   - Show MainMenu → Game → Settings
   - Call `ShowScreenAndClearStack(Screen.MainMenu)`
   - Expected: Stack cleared, MainMenu shown, GoBack() does nothing

7. **TC7: Screen Events**
   - Subscribe to OnScreenEnter and OnScreenExit
   - Call `ShowScreen(Screen.MainMenu)`
   - Expected: OnScreenEnter fires with Screen.MainMenu
   - Call `ShowScreen(Screen.Game)`
   - Expected: OnScreenExit fires with Screen.MainMenu, OnScreenEnter fires with Screen.Game

8. **TC8: Double-Tap Prevention**
   - Call `ShowScreen(Screen.MainMenu, animate: true)` twice rapidly
   - Expected: Second call ignored, warning logged, no errors

9. **TC9: Stack Depth Limit**
   - Show 12 different screens sequentially
   - Expected: Stack limited to 10, oldest entry removed, no errors

### Performance Tests

**Metrics to Verify:**

- Frame rate: 60 FPS maintained during screen transitions
- Memory: No allocations during ShowScreen calls (after initial setup)
- Transition latency: 0.3 seconds total (0.15s fade out + 0.15s fade in)

---

## Dependencies

**Story Dependencies:**

- Story 1.1 (DOTween) - Required for fade transition animations

**Technical Dependencies:**

- Boot scene exists (current status: ✅ Complete)
- DOTween package installed (Story 1.1)

**Asset Dependencies:**

- None (test screens can be empty GameObjects with Image components)

---

## Definition of Done

- [ ] UIManager singleton implemented with all methods
- [ ] Screen enum created with all current screen types
- [ ] UIManager GameObject added to Boot scene
- [ ] Singleton pattern verified (persists across scenes)
- [ ] Screen registration and switching tested (with/without animation)
- [ ] Back button navigation tested (screen stack working)
- [ ] Screen lifecycle events tested (OnScreenEnter, OnScreenExit)
- [ ] Double-tap prevention verified
- [ ] Stack depth limit verified
- [ ] Performance profiled (60 FPS during transitions)
- [ ] No console errors or warnings
- [ ] XML documentation complete on all public methods

---

## Notes

**Implementation Notes:**

- Use DOTween's `DOFade` for smooth canvas fade (requires Story 1.1 complete)
- CanvasScaler set to 1080x1920 (portrait) with 0.5 match - adjust in Epic 5 if landscape needed
- Screen GameObjects will be created in Epic 5 as prefabs, this story just sets up the management system

**Design Decisions:**

- **Screen Stack vs State Machine:** Stack chosen for simplicity and back button support. State machine deferred to V1.1+ if complex transitions needed.
- **CanvasGroup vs Animator:** CanvasGroup + DOTween chosen for lightweight transitions. Animator controllers deferred to Epic 7 if complex animation sequences needed.
- **Runtime Canvas Creation:** Canvas created at runtime to ensure UIManager works without manual setup. Epic 5 may replace with prefab if custom Canvas settings needed.

**Future Considerations:**

- Epic 5: Replace runtime Canvas with prefab Canvas for custom sorting layers, camera setup
- Epic 7: Add slide transitions (left/right), scale transitions for more variety
- V1.1: Add screen transition callbacks (OnTransitionComplete) for chained actions
- V1.2: Add loading screen support (async scene loading with progress bar)

---

**Story Created:** 2025-10-21
**Last Updated:** 2025-10-21
**Created By:** Jordan (Game Scrum Master)
